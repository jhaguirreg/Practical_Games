# -*- coding: utf-8 -*-
"""Ocho_Reinas_VClase.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OQ-YRj9mIScLvVUAyxWiKzOm95036hfv

# Problema de las 8 reinas

Realice la implementación del problema de las 8 reinas usando Algoritmos Genéticos
"""

import numpy as np
import matplotlib.pyplot as plt

def poblacion_inicial(tamano_de_poblacion):
    # Debe retornar una matriz de (tamaño de poblacion, 8)
    # Cada fila de la matriz representa un individuo con su gen de 8 elementos

    cantidad_reinas = 8
    poblacion=np.random.randint(low=1,high=9,size=(tamano_de_poblacion,cantidad_reinas))#tablero

    return poblacion

def funcion_idoneidad(poblacion):
    # Debe retornar un vector de tamaño (tamaño poblacion) en el que cada elemento del vector
    # es el valor de idoneidad cada individuo

    ataques_posibles=28

    idoneidad=np.zeros(len(poblacion))

    for indice_candidato in range(len(poblacion)):
      ataques=0
      for i in range(len(poblacion[0])):
        for j in range(i+1,len(poblacion[0])):
          if poblacion[indice_candidato,i]==poblacion[indice_candidato,j]:
            ataques += 1
          if abs(poblacion[indice_candidato,i]-poblacion[indice_candidato,j])==j-i:
            ataques += 1
      idoneidad[indice_candidato]=ataques_posibles-ataques

    return idoneidad

def seleccion(poblacion,fun_idoneidad):
  ponderados = fun_idoneidad/np.sum(fun_idoneidad)

  indice1,indice2= np.random.choice(len(ponderados),size=2,p=ponderados,replace=False)
  return poblacion[indice1,:],poblacion[indice2,:]

def cross_over(padre1,padre2):
  # Retorna los dos hijos producto del cross-over entre padre1 y padre2
  indice=np.random.choice(range(len(padre1)),1)[0]

  hijo1=np.concatenate((padre1[:indice],padre2[indice:]))
  hijo2=np.concatenate((padre2[:indice],padre1[indice:]))

  return hijo1,hijo2

def mutacion(hijo1,hijo2):
  # Retorna los dos hijos mutados
  p=0.02

  for i in range(len(hijo1)):
    r1 = np.random.rand()
    r2 = np.random.rand()

    if(r1<p):
       hijo1[i]=np.random.choice(range(1,len(hijo1)+1),1)[0]

    if(r2<p):
          hijo2[i]=np.random.choice(range(1,len(hijo2)+1),1)[0]

  """ Otra forma:
      cambio1=np.random.choice((True,False),1,p=(p,1-p))[0]
      cambio2=np.random.choice((True,False),1,p=(p,1-p))[0]

      if cambio1:
        hijo1[i]=np.random.choice(range(1,len(hijo1)+1),1)[0]

      if cambio2:
        hijo2[i]=np.random.choice(range(1,len(hijo2)+1),1)[0]"""
  return hijo1,hijo2

# Loop principal que repite el proceso a través de un número determinado de generaciones
tam_poblacion=40 # Debe ser par
poblacion=poblacion_inicial(tam_poblacion)

idoneidad=funcion_idoneidad(poblacion)

promedios=np.array([])
nueva_poblacion=np.empty((0,8))


if 28 in idoneidad:
  indice=np.argwhere(idoneidad==28)
  print(f"Soluciones: {poblacion[indice[0],:]}")
else:
  solucion=False

while not(solucion):

  while len(nueva_poblacion)<len(poblacion):
    padre1,padre2=seleccion(poblacion,idoneidad)
    hijo1,hijo2=cross_over(padre1,padre2)
    hijo1,hijo2=mutacion(hijo1,hijo2)
    nueva_poblacion=np.vstack([nueva_poblacion,hijo1])
    nueva_poblacion=np.vstack([nueva_poblacion,hijo2])

  poblacion=nueva_poblacion.copy()

  idoneidad=funcion_idoneidad(poblacion)
  promedio_idoneidad=sum(idoneidad)/len(idoneidad)
  promedios=np.append(promedios,promedio_idoneidad)
  nueva_poblacion=np.empty((0,8))

  if 28 in idoneidad:
    indice=np.argwhere(idoneidad==28)
    print(f"Solucion: {poblacion[indice[0]]}")
    solucion=True